<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Collect the Fruit!</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: manipulation;
    }

    .game-area {
      position: relative;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #87CEEB 0%, #98D98E 100%);
      cursor: pointer;
    }

    .animal {
      position: absolute;
      width: 180px;
      height: 240px;
      left: 50px;
      top: 50%;
      transform: translate(-50%, -50%);
      transition: none;
      pointer-events: none;
      object-fit: contain;
    }

    .animal.pop {
      animation: animalPop 0.3s ease-out;
    }

    .animal.happy-hop {
      animation: happyHop 0.8s ease-out;
    }

    @keyframes animalPop {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }

    @keyframes happyHop {
      0% { transform: translate(-50%, -50%) translateY(0) scale(1); }
      25% { transform: translate(-50%, -50%) translateY(-40px) scale(1.1); }
      50% { transform: translate(-50%, -50%) translateY(-20px) scale(1.1); }
      75% { transform: translate(-50%, -50%) translateY(-30px) scale(1.1); }
      100% { transform: translate(-50%, -50%) translateY(0) scale(1); }
    }

    .animal.facing-left {
      transform: translate(-50%, -50%) scaleX(-1);
    }

    .animal.facing-left.pop {
      animation: animalPopLeft 0.3s ease-out;
    }

    @keyframes animalPopLeft {
      0%, 100% { transform: translate(-50%, -50%) scaleX(-1) scale(1); }
      50% { transform: translate(-50%, -50%) scaleX(-1) scale(1.2); }
    }

    .fruit.shake {
      animation: fruitShake 0.4s ease-out;
    }

    @keyframes fruitShake {
      0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
      20% { transform: translate(-50%, -50%) rotate(-15deg); }
      40% { transform: translate(-50%, -50%) rotate(15deg); }
      60% { transform: translate(-50%, -50%) rotate(-10deg); }
      80% { transform: translate(-50%, -50%) rotate(10deg); }
    }

    .fruit {
      position: absolute;
      width: 50px;
      height: 50px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: transform 0.3s ease-out;
      object-fit: contain;
    }

    .fruit[data-type="strawberry"] {
      width: 100px;
      height: 100px;
    }

    .fruit[data-type="blueberry"].faded {
      opacity: 0.3;
      transition: opacity 0.5s ease-out;
    }

    .fruit.collecting {
      transform: translate(-50%, -50%) scale(0);
    }

    .confetti {
      position: fixed;
      width: 10px;
      height: 10px;
      pointer-events: none;
      z-index: 1000;
    }

    .confetti-piece {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 2px;
      animation: confettiFall 3s ease-out forwards;
    }

    @keyframes confettiFall {
      0% {
        transform: translateY(0) rotate(0deg);
      }
      100% {
        transform: translateY(110vh) rotate(720deg);
      }
    }

    .game-header {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      text-align: center;
      padding: 15px;
      pointer-events: none;
      z-index: 100;
    }

    .game-title {
      font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
      font-size: 2.5rem;
      color: #560269;
      margin-bottom: 8px;
    }

    .game-directions {
      font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
      font-size: 1.1rem;
      color: #104e94;
    }

    .reset-button {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 12px 24px;
      font-family: 'Comic Sans MS', 'Chalkboard', cursive, sans-serif;
      font-size: 1.2rem;
      background-color: #9006af;
      color: white;
      border: none;
      border-radius: 25px;
      cursor: pointer;
      box-shadow: 0 4px 0 #560269;
      z-index: 100;
      transition: transform 0.1s, box-shadow 0.1s, opacity 0.3s;
      opacity: 0;
      pointer-events: none;
    }

    .reset-button.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .reset-button:hover {
      transform: translate(-50%, -50%) translateY(-2px);
      box-shadow: 0 6px 0 #560269;
    }

    .reset-button:active {
      transform: translate(-50%, -50%) translateY(2px);
      box-shadow: 0 2px 0 #560269;
    }
  </style>
</head>
<body>
  <div class="game-area" id="gameArea">
    <div class="game-header">
      <h1 class="game-title">Collect the Fruit!</h1>
      <p class="game-directions">Tap where you want the animal to go. Collect all 5 strawberries!</p>
    </div>
    <img class="animal" id="animal" src="images/animal.png" alt="animal">
    <!-- Fruit elements added by JS for flexible positioning -->
    <button class="reset-button" id="resetButton">Play Again</button>
  </div>

  <script>
    (function() {
      const gameArea = document.getElementById('gameArea');
      const animal = document.getElementById('animal');

      const ANIMAL_SPEED = 4;
      const COLLISION_RADIUS = 45;
      const FRUIT_COUNT = 10;
      const FRUITS_TO_WIN = 5;
      const COLORS = ['#E74C3C', '#F39C12', '#2ECC71', '#9B59B6', '#3498DB'];

      let animalX = 50;
      let animalY = 0;
      let destX = null;
      let destY = null;
      let collectedCount = 0;
      let gameWon = false;
      let animationId = null;

      function initAnimalPosition() {
        const rect = gameArea.getBoundingClientRect();
        animalY = rect.height / 2;
        animal.style.left = animalX + 'px';
        animal.style.top = animalY + 'px';
      }

      function createFruit() {
        const fruits = [];
        const rect = gameArea.getBoundingClientRect();
        const padding = 80;
        const leftPadding = 250; // Extra space to avoid chipmunk starting position
        const topPadding = 120; // Extra space to avoid title and directions

        for (let i = 0; i < FRUIT_COUNT; i++) {
          const fruit = document.createElement('img');
          fruit.className = 'fruit';
          
          // First 5 are strawberries, next 5 are blueberries
          const isStrawberry = i < 5;
          fruit.src = isStrawberry ? 'images/strawberry.png' : 'images/blueberry.png';
          fruit.alt = isStrawberry ? 'strawberry' : 'blueberry';
          fruit.dataset.type = isStrawberry ? 'strawberry' : 'blueberry';
          fruit.dataset.index = i;

          let x, y;
          let attempts = 0;
          do {
            x = leftPadding + Math.random() * (rect.width - leftPadding - padding);
            y = topPadding + Math.random() * (rect.height - topPadding - padding);
            attempts++;
          } while (attempts < 50 && fruits.some(f => {
            const dx = Math.abs(f.x - x);
            const dy = Math.abs(f.y - y);
            return dx < 80 && dy < 80;
          }));

          fruit.style.left = x + 'px';
          fruit.style.top = y + 'px';

          gameArea.appendChild(fruit);
          fruits.push({ el: fruit, x, y, type: fruit.dataset.type });
        }

        return fruits;
      }

      let fruits = [];

      function getEventPosition(e) {
        const rect = gameArea.getBoundingClientRect();
        if (e.touches && e.touches.length > 0) {
          return {
            x: e.touches[0].clientX - rect.left,
            y: e.touches[0].clientY - rect.top
          };
        }
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
      }

      function handleTap(e) {
        if (gameWon) return;
        e.preventDefault();
        const pos = getEventPosition(e);
        destX = pos.x;
        destY = pos.y;

        // Flip animal based on target direction
        if (destX < animalX) {
          animal.classList.add('facing-left');
        } else {
          animal.classList.remove('facing-left');
        }
      }

      gameArea.addEventListener('click', handleTap);
      gameArea.addEventListener('touchstart', handleTap, { passive: false });

      function distance(x1, y1, x2, y2) {
        return Math.hypot(x2 - x1, y2 - y1);
      }

      function checkCollision() {
        const animalCenterX = animalX;
        const animalCenterY = animalY;

        fruits.forEach(({ el, x, y }) => {
          if (el.classList.contains('collecting')) return;

          const dist = distance(animalCenterX, animalCenterY, x, y);
          const inRange = dist < COLLISION_RADIUS;

          if (el.dataset.type === 'blueberry') {
            if (inRange) {
              // Only reject if not already rejected during this encounter
              if (!el.dataset.rejected) {
                rejectBlueberry(el);
              }
            } else {
              // Animal left the zone, clear rejected state
              delete el.dataset.rejected;
            }
          } else if (inRange) {
            collectFruit(el);
          }
        });
      }

      function rejectBlueberry(el) {
        el.dataset.rejected = 'true';
        playErrorSound();
        el.classList.add('shake');
        
        // Stop the animal - wait for next tap to continue
        destX = null;
        destY = null;

        setTimeout(() => {
          el.classList.remove('shake');
        }, 500);
      }

      function playCollectSound() {
        const audio = new Audio('sounds/collect.mp3');
        audio.volume = 0.5;
        audio.play().catch(() => {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.frequency.value = 523;
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.2, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.15);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.15);
          } catch (_) {}
        });
      }

      function playCheerSound() {
        const audio = new Audio('sounds/cheer.mp3');
        audio.volume = 0.5;
        audio.play().catch(() => {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const notes = [523, 659, 784, 1047];
            notes.forEach((freq, i) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.connect(gain);
              gain.connect(ctx.destination);
              osc.frequency.value = freq;
              osc.type = 'sine';
              const t = ctx.currentTime + i * 0.15;
              gain.gain.setValueAtTime(0.2, t);
              gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
              osc.start(t);
              osc.stop(t + 0.2);
            });
          } catch (_) {}
        });
      }

      function playErrorSound() {
        const audio = new Audio('sounds/error.mp3');
        audio.volume = 0.5;
        audio.play().catch(() => {
          try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.frequency.value = 200;
            osc.type = 'square';
            gain.gain.setValueAtTime(0.15, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.2);
          } catch (_) {}
        });
      }

      function collectFruit(el) {
        el.classList.add('collecting');
        animal.classList.add('pop');
        playCollectSound();

        setTimeout(() => {
          animal.classList.remove('pop');
        }, 300);

        const isStrawberry = el.dataset.type === 'strawberry';

        let removed = false;
        function removeFruit() {
          if (removed) return;
          removed = true;
          el.remove();
          
          // Only count strawberries toward the win condition
          if (isStrawberry) {
            collectedCount++;
            if (collectedCount >= FRUITS_TO_WIN) {
              triggerWinCelebration();
            }
          }
        }

        el.addEventListener('transitionend', removeFruit, { once: true });
        // Fallback in case transitionend doesn't fire
        setTimeout(removeFruit, 350);
      }

      function triggerWinCelebration() {
        gameWon = true;
        destX = null;
        destY = null;

        animal.classList.add('happy-hop');
        playCheerSound();

        setTimeout(() => {
          animal.classList.remove('happy-hop');
          spawnConfetti();
        }, 800);
      }

      function spawnConfetti() {
        // Fade out remaining blueberries
        document.querySelectorAll('.fruit[data-type="blueberry"]').forEach(b => {
          b.classList.add('faded');
        });

        const rect = gameArea.getBoundingClientRect();
        const count = 100;
        const colors = ['#E74C3C', '#F39C12', '#2ECC71', '#9B59B6', '#3498DB', '#1ABC9C', '#E91E63'];

        for (let i = 0; i < count; i++) {
          const piece = document.createElement('div');
          piece.className = 'confetti-piece';
          piece.style.backgroundColor = colors[i % colors.length];
          piece.style.left = (Math.random() * rect.width) + 'px';
          piece.style.top = (-10 - Math.random() * 20) + 'px';
          piece.style.animationDelay = (Math.random() * 0.8) + 's';

          gameArea.appendChild(piece);

          setTimeout(() => piece.remove(), 5000);
        }

        // Show reset button after 2 seconds
        setTimeout(() => {
          document.getElementById('resetButton').classList.add('visible');
        }, 2000);
      }

      function gameLoop() {
        if (destX !== null && destY !== null && !gameWon) {
          const dx = destX - animalX;
          const dy = destY - animalY;
          const dist = Math.hypot(dx, dy);

          if (dist > 2) {
            const moveX = (dx / dist) * ANIMAL_SPEED;
            const moveY = (dy / dist) * ANIMAL_SPEED;
            animalX += moveX;
            animalY += moveY;
          } else {
            destX = null;
            destY = null;
          }

          animal.style.left = animalX + 'px';
          animal.style.top = animalY + 'px';

          checkCollision();
        }

        animationId = requestAnimationFrame(gameLoop);
      }

      function init() {
        initAnimalPosition();
        fruits = createFruit();
        gameLoop();
      }

      function resetGame() {
        // Hide reset button
        document.getElementById('resetButton').classList.remove('visible');
        // Remove existing fruit
        document.querySelectorAll('.fruit').forEach(f => f.remove());
        // Remove any confetti
        document.querySelectorAll('.confetti-piece').forEach(c => c.remove());
        // Reset state
        collectedCount = 0;
        gameWon = false;
        destX = null;
        destY = null;
        // Reset animal position and classes
        animalX = 50;
        animal.classList.remove('happy-hop', 'pop', 'facing-left');
        initAnimalPosition();
        // Create new fruit
        fruits = createFruit();
      }

      document.getElementById('resetButton').addEventListener('click', (e) => {
        e.stopPropagation();
        resetGame();
      });

      window.addEventListener('load', init);
      window.addEventListener('resize', () => {
        initAnimalPosition();
      });
    })();
  </script>
</body>
</html>
